---
layout: post
title: "파이썬의 가상환경에 대하여"
tags:
  - python
---

## ---

개인 프로젝트를 진행하던 중 venv 기능을 끌어와서 만들어주어야 할 것이 생겨서 venv, virtualenv안의 코드를 좀 보았었는데, 몇개월 지나다보니 다 까먹어서... 다시 보면서 포스트로 정리하기로 했다. 파이썬 3.7 버전이 기준이다.

## venv

python3.3 버전 이후부터 [venv 모듈](https://github.com/python/cpython/tree/3.7/Lib/venv/)을 사용할 수 있다. 해당 모듈은 [python 3.7.2 문서](https://docs.python.org/3/library/venv.html#module-venv)에서 다음과 같이 설명한다.

> The venv module provides support for creating lightweight “virtual environments” with their own site directories, optionally isolated from system site directories. Each virtual environment has its own Python binary (which matches the version of the binary that was used to create this environment) and can have its own independent set of installed Python packages in its site directories. 

즉 원래 `virtualenv` 모듈을 사용하는 것 대신, 아래와 같은 명령어로 경량의 가상환경을 구축할 수 있다는 것이다. (그래도 난 pyenv랑 같이 쓰는 virtualenv가 더 좋아요..)

```shell
python3 -m venv /path/to/new/virtual/environment
```

### 실제 동작 방식

그럼 어떻게 venv를 사용했을 때 전역으로 설치하지 않고 각자의 site directory를 가질 수 있는지 궁금해져서 코드를 가져와 보았다. (중간에 argparse에 인자 추가하는 것들은 그냥 지웠다)

```python
def main(args=None):
    compatible = True
    if sys.version_info < (3, 3):
        compatible = False
    elif not hasattr(sys, 'base_prefix'):
        compatible = False
    if not compatible:
        raise ValueError('This script is only for use with Python >= 3.3')
    else:
        import argparse

        ...

        options = parser.parse_args(args)
        if options.upgrade and options.clear:
            raise ValueError('you cannot supply --upgrade and --clear together.')
        builder = EnvBuilder(system_site_packages=options.system_site,
                             clear=options.clear,
                             symlinks=options.symlinks,
                             upgrade=options.upgrade,
                             with_pip=options.with_pip,
                             prompt=options.prompt)
        for d in options.dirs:
            builder.create(d)
```

`venv` 모듈안의 `__init__.py`나, `__main__.py`나 둘 다 위의 `main`함수를 호출한다. 먼저 python3.3보다 큰지, `base_prefix` 속성이 `sys` 모듈에 존재하는지만 보고 있다. 존재할 경우 인자들을 파싱하여 `EnvBuilder` 클래스에 인자들을 전달하는데, 이 `EnvBuilder`는 아래에서 살펴보겠다. 여튼, 그렇게 만들고 위의 사용방법에서 넘긴 경로들(여러개가 지정이 가능하다. 코드를 살펴보면 ```parser.add_argument('dirs', metavar='ENV_DIR', nargs='+', help='A directory to create the environment in.')```와 같은 형태로 사용한다)에 대해 모두 가상환경을 만들어주는 모습이다.

#### EnvBuilder

여튼 그래서 `EnvBuilder`를 살펴보자면 아래처럼 주석이 적혀있고, `__init__`이 선언되어 있다.

```python
class EnvBuilder:
    """
    This class exists to allow virtual environment creation to be
    customized. The constructor parameters determine the builder's
    behaviour when called upon to create a virtual environment.
    By default, the builder makes the system (global) site-packages dir
    *un*available to the created environment.
    If invoked using the Python -m option, the default is to use copying
    on Windows platforms but symlinks elsewhere. If instantiated some
    other way, the default is to *not* use symlinks.
    :param system_site_packages: If True, the system (global) site-packages
                                 dir is available to created environments.
    :param clear: If True, delete the contents of the environment directory if
                  it already exists, before environment creation.
    :param symlinks: If True, attempt to symlink rather than copy files into
                     virtual environment.
    :param upgrade: If True, upgrade an existing virtual environment.
    :param with_pip: If True, ensure pip is installed in the virtual
                     environment
    :param prompt: Alternative terminal prefix for the environment.
    """

    def __init__(self, system_site_packages=False, clear=False,
                 symlinks=False, upgrade=False, with_pip=False, prompt=None):
        self.system_site_packages = system_site_packages
        self.clear = clear
        self.symlinks = symlinks
        self.upgrade = upgrade
        self.with_pip = with_pip
        self.prompt = prompt
    
    ...
```

즉, 가상환경을 만들 때 커스터마이제이션을 쉽게 하기 위해서 클래스 형태로 작성을 해놓았다. 여튼 `__init__`에서는 행동을 정의해주기만 하고, 그럼 `create`는 어떻게 하는지 알아보자.

```python
class EnvBuilder:
    ...

    def create(self, env_dir):
        """
        Create a virtual environment in a directory.
        :param env_dir: The target directory to create an environment in.
        """
        env_dir = os.path.abspath(env_dir)
        context = self.ensure_directories(env_dir)
        # See issue 24875. We need system_site_packages to be False
        # until after pip is installed.
        true_system_site_packages = self.system_site_packages
        self.system_site_packages = False
        self.create_configuration(context)
        self.setup_python(context)
        if not self.upgrade:
            self.setup_scripts(context)
        if self.with_pip:
            self._setup_pip(context)
        if not self.upgrade:
            self.post_setup(context)
        if true_system_site_packages:
            # We had set it to False before, now
            # restore it and rewrite the configuration
            self.system_site_packages = True
            self.create_configuration(context)
```

보면 실제로 가상환경을 생성해주는 함수인데, 위에서부터 하나하나 보자.

`ensure_directories`는 실제로 경로가 존재하는지 체크하고, 
